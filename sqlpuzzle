https://www.stratascratch.com/blog/types-of-window-functions-in-sql-and-questions-asked-by-airbnb-netflix-twitter-and-uber/

Aggregation
Ranking
Ntiles
Lag/lead

1: distance_per_dollar question Uber
https://platform.stratascratch.com/coding/10302-distance-per-dollar?code_type=1
You’re given a dataset of uber rides with the traveling distance (‘distance_to_travel’) and cost (‘monetary_cost’) for each ride. First, find the difference between the distance-per-dollar for each date and the average distance-per-dollar for that year-month. Distance-per-dollar is defined as the distance traveled divided by the cost of the ride. Use the calculated difference on each date to calculate absolute average difference in distance-per-dollar metric on monthly basis (year-month).


The output should include the year-month (YYYY-MM) and the absolute average difference in distance-per-dollar (Absolute value to be rounded to the 2nd decimal).
You should also count both success and failed request_status as the distance and cost values are populated for all ride requests. Also, assume that all dates are unique in the dataset. Order your results by earliest request date first.


You’re given a dataset of uber rides with the traveling distance (‘distance_to_travel’) and cost (‘monetary_cost’) for each ride. First, find the difference between the distance-per-dollar for each date and the average distance-per-dollar for that year-month. Distance-per-dollar is defined as the distance traveled divided by the cost of the ride. Use the calculated difference on each date to calculate absolute average difference in distance-per-dollar metric on monthly basis (year-month).

--The output should include the year-month (YYYY-MM) and the absolute average difference in distance-per-dollar (Absolute value to be rounded to the 2nd decimal).

You should also count both success and failed request_status as the distance and cost values are populated for all ride requests. Also, assume that all dates are unique in the dataset. Order your results by earliest request date first.

The demo sample query is wrong as he only calculated the avg function on the dist_per_cost in his first x min video, but he corrected the alias and calculation in final video.

Use window function can reduce sub-query usage, but still can work this out without using window function



/* Write your SQL here. Terminate each statement with a semicolon. */


    with base as
    (select request_date
    ,to_char(request_date,'YYYY-MM') as request_ym 
    ,distance_to_travel/monetary_cost as distance_per_dollar
    from uber_request_logs),
    agg as (
    select request_date
    ,distance_per_dollar
    ,avg(distance_per_dollar) over(partition by request_ym ) as avg_distance_per_dollar
    from base)
    select  request_date
    ,round(abs(distance_per_dollar-avg_distance_per_dollar)::decimal,2) as avg_diff
    from agg
    order by request_date
    ;
	

2:unique salary Twitter
Unique Salaries
Find the top three unique salaries for each department. Output the department name and the top 3 unique salaries by each department. Order your results alphabetically by department and then by highest salary to lowest.

https://platform.stratascratch.com/coding/9897-highest-salary-in-department?code_type=1 (the original problem in demo seems gone, this is the closest one)

usually in redshift, it's quick and no need to dedup first, but the demo solution provided in strata scratch used group by to dedup first, use dense_rank or rank depends on the request how to handle ties.
Three main functions can use to find the highest would be rank, dense_rank, row_number(when there is a tie, this is useful, it just return exact three rows if there are larger than three rows meet the criteria)
With base as (
Select distinct department 
,salary
,dense_rank() over (partition by department order by salary desc) as rank_salaries
From twitter_employee)
Select  department
,salary
From base 
Where rm_salaries <=3
Order by department, salary desc


3: fraud
https://platform.stratascratch.com/coding/10303-top-percentile-fraud?code_type=1
ABC Corp is a mid-sized insurer in the US and in the recent past their fraudulent claims have increased significantly for their personal auto insurance portfolio. They have developed a ML based predictive model to identify propensity of fraudulent claims. Now, they assign highly experienced claim adjusters for top 5 percentile of claims identified by the model.
Your objective is to identify the top 5 percentile of claims from each state. Your output should be policy number, state, claim cost, and fraud score.

NTILE N Bins
Ntile 100 - percentile
Ntile 4 —Quartile
Ntile 10 —Decile


With base as (
Select
policy_num
,state
,claim_cost
,fraud_score
,ntile(100) over (partition by state order by fraud_score desc) as percentile_num
From fraud_score )
Select distinct policy_num
,state
,claim_cost
,fraud_score
,percentile_num
From base where percentile_num <=5;



4:growth of Airbnb
https://platform.stratascratch.com/coding/9637-growth-of-airbnb?code_type=1

Estimate the growth of Airbnb each year using the number of hosts registered as the growth metric. The rate of growth is calculated by taking ((number of hosts registered in the current year - number of hosts registered in the previous year) / the number of hosts registered in the previous year) * 100.
Output the year, number of hosts in the current year, number of hosts in the previous year, and the rate of growth. Round the rate of growth to the nearest percent and order the result in the ascending order based on the year.
Assume that the dataset consists only of unique hosts, meaning there are no duplicate hosts listed.

--solution 1
with base as (
select to_char(host_since,'YYYY') as year
,count(id) as host_cnt
from airbnb_search_details
group by to_char(host_since,'YYYY'))
,
pre as (
select year
,host_cnt
,lag(host_cnt,1) over (order by year ) as pre_year_host_cnt
from base 
)
select *
--if it's blank, leave it as blank since cannot calculate the growth rate, but can double confirm the request
--,case when pre_year_host_cnt is null then 100 else round((1.00* (host_cnt-pre_year_host_cnt)/(pre_year_host_cnt) * 100)) end as growth_rate
--use 1.00 and cast would result in same result
--round(((host_cnt-pre_year_host_cnt)/cast(pre_year_host_cnt as numeric)) * 100) end as growth_rate
,round((1.00* (host_cnt-pre_year_host_cnt)/(pre_year_host_cnt) * 100))  as growth_rate
from pre
order by year
;

--solution 2:
--can also also use extract function and self join if requires to not use window function like lag
WITH base AS (
    SELECT 
        EXTRACT(YEAR FROM host_since) AS year,
        COUNT(id) AS host_cnt
    FROM 
        airbnb_search_details
    GROUP BY 
        EXTRACT(YEAR FROM host_since)
)
, pre AS (
    SELECT 
        b1.year AS year,
        b1.host_cnt AS host_cnt,
        b2.host_cnt AS pre_year_host_cnt
    FROM 
        base b1
    LEFT JOIN base b2 ON b1.year = b2.year + 1
)
SELECT 
    year,
    host_cnt,
    pre_year_host_cnt,
    CASE
        WHEN pre_year_host_cnt IS NULL THEN NULL
        ELSE ROUND((1.00* (host_cnt - pre_year_host_cnt) / pre_year_host_cnt::NUMERIC) * 100)
    END AS growth_rate
FROM 
    pre
ORDER BY 
    year;
